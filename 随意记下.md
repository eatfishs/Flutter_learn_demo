1、GetX的底层中,GetView基于stateLess,Obx基于stateFul。<br/>
2、provider基于ChangeNotifer实现，观察者模式实现，bloc是在provider的基础上封装一层，getx是基于InheritedWidget和依赖注入方式实现。<br/>
3、图片绘制流程 从imagePrivider入手，找到resolve方法，再找到imageStream key  缓存 。。。。。。好多好多，艰难读源码 <br/>
   实现一个 ImageProvider 很简单，只需要实现 load 和 obtainKey 方法
   ```
      /// Subclasses should implement [obtainKey] and [load], which are used by this
      /// method. If they need to change the implementation of [ImageStream] used,
     /// they should override [createStream]. If they need to manage the actual
     /// resolution of the image, they should override [resolveStreamForKey].
   ```


4、typedef https://juejin.cn/post/6986794034903646215 <br/>
5、<br/> https://www.jianshu.com/p/d1f752a49051
 ProxyWidget： 一个抽象的代理Widget,并没有实质作用，只有在父类和子类需要传递消息时使用， <br/>
 InheritedWidget 子类状态变更时可以通知父类进行对应的变更,可理解为数据上移 <br/>
 ParentDataWidget 作用与InheritedWidget正相反，主要用于为具有多个子类的RenderDataWidget <br/>
 提供对应的配置，如Stack使用已经定位好的父类Widget来定位每个子Widget,可理解为数据下移 <br/>
 6、SliverToBoxAdapter<br/>
  会需要重写<br/>
    @override<br/>
    RenderSliverToBoxAdapter createRenderObject(BuildContext context) => RenderSliverToBoxAdapter();<br/>
    关键点：<br/>
    final SliverConstraints constraints = this.constraints;<br/>
    child!.layout(constraints.asBoxConstraints(), parentUsesSize: true);<br/>
