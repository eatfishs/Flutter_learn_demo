1、GetX的底层中,GetView基于stateLess,Obx基于stateFul。<br/>
2、provider基于ChangeNotifer实现，观察者模式实现，bloc是在provider的基础上封装一层，getx是基于InheritedWidget和依赖注入方式实现。<br/>
3、图片绘制流程 从imagePrivider入手，找到resolve方法，再找到imageStream key  缓存 。。。。。。好多好多，艰难读源码 <br/>
   实现一个 ImageProvider 很简单，只需要实现 `load` 和 `obtainKey` 方法
   ```
      /// Subclasses should implement [obtainKey] and [load], which are used by this
      /// method. If they need to change the implementation of [ImageStream] used,
     /// they should override [createStream]. If they need to manage the actual
     /// resolution of the image, they should override [resolveStreamForKey].

 /// The [ImageProvider] goes through the following lifecycle to resolve an
/// image, once the [resolve] method is called:
///
///   1. Create an [ImageStream] using [createStream] to return to the caller.
///      This stream will be used to communicate back to the caller when the
///      image is decoded and ready to display, or when an error occurs.
///   2. Obtain the key for the image using [obtainKey].
///      Calling this method can throw exceptions into the zone asynchronously
///      or into the callstack synchronously. To handle that, an error handler
///      is created that catches both synchronous and asynchronous errors, to
///      make sure errors can be routed to the correct consumers.
///      The error handler is passed on to [resolveStreamForKey] and the
///      [ImageCache].
///   3. If the key is successfully obtained, schedule resolution of the image
///      using that key. This is handled by [resolveStreamForKey]. That method
///      may fizzle if it determines the image is no longer necessary, use the
///      provided [ImageErrorListener] to report an error, set the completer
///      from the cache if possible, or call [loadBuffer] to fetch the encoded image
///      bytes and schedule decoding.
///   4. The [loadBuffer] method is responsible for both fetching the encoded bytes
///      and decoding them using the provided [DecoderCallback]. It is called
///      in a context that uses the [ImageErrorListener] to report errors back.

   ```


4、typedef https://juejin.cn/post/6986794034903646215 <br/>
5、<br/> https://www.jianshu.com/p/d1f752a49051
 ProxyWidget： 一个抽象的代理Widget,并没有实质作用，只有在父类和子类需要传递消息时使用， <br/>
 InheritedWidget 子类状态变更时可以通知父类进行对应的变更,可理解为数据上移 <br/>
 ParentDataWidget 作用与InheritedWidget正相反，主要用于为具有多个子类的RenderDataWidget <br/>
 提供对应的配置，如Stack使用已经定位好的父类Widget来定位每个子Widget,可理解为数据下移 <br/>
 6、SliverToBoxAdapter<br/>
 
```
  会需要重写<br/>
    @override<br/>
    RenderSliverToBoxAdapter createRenderObject(BuildContext context) => RenderSliverToBoxAdapter();<br/>
    关键点：<br/>
    final SliverConstraints constraints = this.constraints;<br/>
    child!.layout(constraints.asBoxConstraints(), parentUsesSize: true);<br/>
```

7、InheritedWidget主要创建变量，自上而下的让子类去感知到。ChangeNotifier类似一个观察者通知更新UI <br/>
8、一键置灰效果:<br/>

```
  runApp(
    ColorFiltered(
        colorFilter: ColorFilter.mode(Colors.white, BlendMode.color),
        child: FlutterApp())));

```
9、关键字covariant的作用：
当子类继承自抽象父类的时候，，默认情况下，需要重写其父类方法，同时参数不能改变。
如果想要改变参数内容，就可以使用covariant关键字

```

abstract class Fruit {}
class Apple extends Fruit {}
class Grape extends Fruit {}
class Banana extends Fruit {}

abstract class Mammal {
  void eat(Fruit f);
}

class Human extends Mammal {
  // Ok
  @override
  void eat(Fruit f) => print("Fruit");
}

class Monkey extends Mammal { 
  // Error  'Monkey.eat' ('void Function(Banana)') isn't a valid override of 'Mammal.eat' ('void Function(Fruit)').dartinvalid_override
  // @override
  // void eat(Banana f) => print("Banana");
  // Ok
  @override
  void eat(covariant Banana f) => print("Banana");
}

```

或者

```

abstract class Fruit {}
class Apple extends Fruit {}
class Grape extends Fruit {}
class Banana extends Fruit {}

abstract class Mammal {
  void eat(covariant Fruit f);
}

class Human extends Mammal {
  // Ok
  @override
  void eat(Fruit f) => print("Fruit");
}
class Monkey extends Mammal {
  // Ok
  @override
  void eat(Banana f) => print("Banana");
}


```
10、 dart的私有，指的永远是文件私有，不是类私有
  

    
