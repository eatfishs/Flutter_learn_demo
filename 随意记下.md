1、GetX的底层中,GetView基于stateLess,Obx基于stateFul。<br/>
2、provider基于ChangeNotifer实现，观察者模式实现，bloc是在provider的基础上封装一层，getx是基于InheritedWidget和依赖注入方式实现。<br/>
3、图片绘制流程 从imagePrivider入手，找到resolve方法，再找到imageStream key  缓存 。。。。。。好多好多，艰难读源码 <br/>
   实现一个 ImageProvider 很简单，只需要实现 `load` 和 `obtainKey` 方法
   ```
      /// Subclasses should implement [obtainKey] and [load], which are used by this
      /// method. If they need to change the implementation of [ImageStream] used,
     /// they should override [createStream]. If they need to manage the actual
     /// resolution of the image, they should override [resolveStreamForKey].

 /// The [ImageProvider] goes through the following lifecycle to resolve an
/// image, once the [resolve] method is called:
///
///   1. Create an [ImageStream] using [createStream] to return to the caller.
///      This stream will be used to communicate back to the caller when the
///      image is decoded and ready to display, or when an error occurs.
///   2. Obtain the key for the image using [obtainKey].
///      Calling this method can throw exceptions into the zone asynchronously
///      or into the callstack synchronously. To handle that, an error handler
///      is created that catches both synchronous and asynchronous errors, to
///      make sure errors can be routed to the correct consumers.
///      The error handler is passed on to [resolveStreamForKey] and the
///      [ImageCache].
///   3. If the key is successfully obtained, schedule resolution of the image
///      using that key. This is handled by [resolveStreamForKey]. That method
///      may fizzle if it determines the image is no longer necessary, use the
///      provided [ImageErrorListener] to report an error, set the completer
///      from the cache if possible, or call [loadBuffer] to fetch the encoded image
///      bytes and schedule decoding.
///   4. The [loadBuffer] method is responsible for both fetching the encoded bytes
///      and decoding them using the provided [DecoderCallback]. It is called
///      in a context that uses the [ImageErrorListener] to report errors back.

   ```


4、typedef https://juejin.cn/post/6986794034903646215 <br/>
5、<br/> https://www.jianshu.com/p/d1f752a49051
 ProxyWidget： 一个抽象的代理Widget,并没有实质作用，只有在父类和子类需要传递消息时使用， <br/>
 InheritedWidget 子类状态变更时可以通知父类进行对应的变更,可理解为数据上移 <br/>
 ParentDataWidget 作用与InheritedWidget正相反，主要用于为具有多个子类的RenderDataWidget <br/>
 提供对应的配置，如Stack使用已经定位好的父类Widget来定位每个子Widget,可理解为数据下移 <br/>
 6、SliverToBoxAdapter<br/>
 
```
  会需要重写<br/>
    @override<br/>
    RenderSliverToBoxAdapter createRenderObject(BuildContext context) => RenderSliverToBoxAdapter();<br/>
    关键点：<br/>
    final SliverConstraints constraints = this.constraints;<br/>
    child!.layout(constraints.asBoxConstraints(), parentUsesSize: true);<br/>
```

7、InheritedWidget主要创建变量，自上而下的让子类去感知到。ChangeNotifier类似一个观察者通知更新UI <br/>
8、一键置灰效果:<br/>

```
  runApp(
    ColorFiltered(
        colorFilter: ColorFilter.mode(Colors.white, BlendMode.color),
        child: FlutterApp())));

```
9、关键字covariant的作用：
当子类继承自抽象父类的时候，，默认情况下，需要重写其父类方法，同时参数不能改变。
如果想要改变参数内容，就可以使用covariant关键字

```

abstract class Fruit {}
class Apple extends Fruit {}
class Grape extends Fruit {}
class Banana extends Fruit {}

abstract class Mammal {
  void eat(Fruit f);
}

class Human extends Mammal {
  // Ok
  @override
  void eat(Fruit f) => print("Fruit");
}

class Monkey extends Mammal { 
  // Error  'Monkey.eat' ('void Function(Banana)') isn't a valid override of 'Mammal.eat' ('void Function(Fruit)').dartinvalid_override
  // @override
  // void eat(Banana f) => print("Banana");
  // Ok
  @override
  void eat(covariant Banana f) => print("Banana");
}

```

或者

```

abstract class Fruit {}
class Apple extends Fruit {}
class Grape extends Fruit {}
class Banana extends Fruit {}

abstract class Mammal {
  void eat(covariant Fruit f);
}

class Human extends Mammal {
  // Ok
  @override
  void eat(Fruit f) => print("Fruit");
}
class Monkey extends Mammal {
  // Ok
  @override
  void eat(Banana f) => print("Banana");
}


```
10、 dart的_私有，指的永远是文件私有，并不是类私有、方法私有 <br/>
  ![image](https://github.com/pheromone/Flutter_learn_demo/blob/master/Dart%E4%B8%AD%E7%9A%84_%E7%A7%81%E6%9C%89%E5%8C%96%E6%98%AF%E6%96%87%E4%BB%B6%E7%9A%84%E7%A7%81%E6%9C%89%E5%8C%96.jpg) <br/>
11、一个组件想要打破原有 紧约束 的方式有：<br/>
[1] 通过 UnconstrainedBox [解除约束]，让自身约束变为 [无约束]。<br/>
[2] 通过 Align、Flex、Stack 等组件 [放松约束]，让自身约束变为 [松约束]。<br/>
[3] 通过 CustomSingleChildLayout 等自定义布局组件施加 [新约束]。<br/>
其实总的来说就是通过嵌套 `布局组件`，来改变自身父级的盒约束。<br/>
12、使用on关键字来限制使用Mixins的类只能是某种类型的子类，例如：

```
mixin Coding on Human {
  void code() {}
}

// All good
class Human {}
class Developer extends Human with Coding {}

// NO, 'Coding' can be used only on subclasses
class Human with Coding {}

// NO, 'Fish' is not a subclass of 'Human' so 
// you cannot attach the 'Coding' mixin
class Fish with Coding {}

```
13、ListView的简单实现逻辑：<br/>
ListView --> BoxScrollView --> ScrollView --> StatelessWidget --> .... <br/>
后面BoxScrollView   ScrollView  StatelessWidget 都是抽象类，都需要实现父类的抽象方法：<br/>
ScrollView重写build方法：在方法内会返回Scrollable(),Scrollable(）是计算偏移量的，
在Scrollable里面会有Viewport返回，其中在ScrollView重写build方法时，会调用到buildSlivers抽象方法。<br/>
BoxScrollView会重写buildSlivers：通过MediaQuery去制造内边距，其余参数通过super构造去传入，其中会调用到buildChildLayout抽象方法。<br/>
ListView会重写buildChildLayout：判断itemExtent、prototypeItem 是由 SliverFixedExtentList 、SliverPrototypeExtentList还是由SliverList 生成。<br/>
......
ScorllView继承自StatelessWidget,CustomScrollView和BoxScollView继承自ScollView,ListView和GridView继承自BoxScrollView

    
